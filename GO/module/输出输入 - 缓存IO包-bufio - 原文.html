<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>输出输入 - 缓存IO包-bufio - 原文 | MSG</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="在追寻技术的同时享受生活">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.d65bef42.js" as="script"><link rel="preload" href="/assets/js/2.2249178e.js" as="script"><link rel="preload" href="/assets/js/58.5afb51cf.js" as="script"><link rel="prefetch" href="/assets/js/10.4785e2e5.js"><link rel="prefetch" href="/assets/js/100.33fceff2.js"><link rel="prefetch" href="/assets/js/101.62e1e5d4.js"><link rel="prefetch" href="/assets/js/102.8551fe71.js"><link rel="prefetch" href="/assets/js/103.47754d79.js"><link rel="prefetch" href="/assets/js/104.4adf114f.js"><link rel="prefetch" href="/assets/js/105.6206a08a.js"><link rel="prefetch" href="/assets/js/106.1c4561f3.js"><link rel="prefetch" href="/assets/js/107.e1531a5a.js"><link rel="prefetch" href="/assets/js/108.c637743a.js"><link rel="prefetch" href="/assets/js/109.3f150913.js"><link rel="prefetch" href="/assets/js/11.bd8ec7a6.js"><link rel="prefetch" href="/assets/js/110.088c1ac3.js"><link rel="prefetch" href="/assets/js/111.66d8d491.js"><link rel="prefetch" href="/assets/js/112.231663ee.js"><link rel="prefetch" href="/assets/js/113.a38bc531.js"><link rel="prefetch" href="/assets/js/114.e165daea.js"><link rel="prefetch" href="/assets/js/115.994b087a.js"><link rel="prefetch" href="/assets/js/116.ea3cfdfb.js"><link rel="prefetch" href="/assets/js/117.7be5e4f3.js"><link rel="prefetch" href="/assets/js/118.ebb58ddb.js"><link rel="prefetch" href="/assets/js/119.90018646.js"><link rel="prefetch" href="/assets/js/12.0d8f43df.js"><link rel="prefetch" href="/assets/js/120.bb5be863.js"><link rel="prefetch" href="/assets/js/121.3d1db670.js"><link rel="prefetch" href="/assets/js/122.d29ed1b2.js"><link rel="prefetch" href="/assets/js/123.38cc4704.js"><link rel="prefetch" href="/assets/js/124.cc8549d4.js"><link rel="prefetch" href="/assets/js/125.6ee3e9c8.js"><link rel="prefetch" href="/assets/js/126.48710eba.js"><link rel="prefetch" href="/assets/js/127.d7a1fd83.js"><link rel="prefetch" href="/assets/js/128.e5017f6b.js"><link rel="prefetch" href="/assets/js/129.4c33e121.js"><link rel="prefetch" href="/assets/js/13.2dbde7aa.js"><link rel="prefetch" href="/assets/js/130.cda66247.js"><link rel="prefetch" href="/assets/js/131.ad76f669.js"><link rel="prefetch" href="/assets/js/132.aca88758.js"><link rel="prefetch" href="/assets/js/133.a1cf5903.js"><link rel="prefetch" href="/assets/js/134.b1386377.js"><link rel="prefetch" href="/assets/js/135.94edcf53.js"><link rel="prefetch" href="/assets/js/136.24be4170.js"><link rel="prefetch" href="/assets/js/137.db57772e.js"><link rel="prefetch" href="/assets/js/138.dc67bcaa.js"><link rel="prefetch" href="/assets/js/139.5453d1f6.js"><link rel="prefetch" href="/assets/js/14.2187dbf4.js"><link rel="prefetch" href="/assets/js/140.938e5c07.js"><link rel="prefetch" href="/assets/js/141.99c7cf2c.js"><link rel="prefetch" href="/assets/js/142.428e3958.js"><link rel="prefetch" href="/assets/js/143.68b01530.js"><link rel="prefetch" href="/assets/js/144.f67389cc.js"><link rel="prefetch" href="/assets/js/145.d952a130.js"><link rel="prefetch" href="/assets/js/146.b933dcad.js"><link rel="prefetch" href="/assets/js/147.2d8e4c0a.js"><link rel="prefetch" href="/assets/js/148.6d76ac94.js"><link rel="prefetch" href="/assets/js/149.6b4d6378.js"><link rel="prefetch" href="/assets/js/15.a53b356c.js"><link rel="prefetch" href="/assets/js/150.5bf39cb4.js"><link rel="prefetch" href="/assets/js/151.17af677c.js"><link rel="prefetch" href="/assets/js/152.7f1c2792.js"><link rel="prefetch" href="/assets/js/153.98dd0727.js"><link rel="prefetch" href="/assets/js/154.eb44bf23.js"><link rel="prefetch" href="/assets/js/155.5a9840ea.js"><link rel="prefetch" href="/assets/js/156.7ba01fd0.js"><link rel="prefetch" href="/assets/js/157.2296a048.js"><link rel="prefetch" href="/assets/js/158.6bb1f699.js"><link rel="prefetch" href="/assets/js/159.073bb8df.js"><link rel="prefetch" href="/assets/js/16.cef7bf44.js"><link rel="prefetch" href="/assets/js/160.25a837f9.js"><link rel="prefetch" href="/assets/js/161.93d886a1.js"><link rel="prefetch" href="/assets/js/162.5d2714b2.js"><link rel="prefetch" href="/assets/js/17.96f36904.js"><link rel="prefetch" href="/assets/js/18.fd04b310.js"><link rel="prefetch" href="/assets/js/19.3e1377d1.js"><link rel="prefetch" href="/assets/js/20.ac195ac8.js"><link rel="prefetch" href="/assets/js/21.c2d7729c.js"><link rel="prefetch" href="/assets/js/22.dd8c621b.js"><link rel="prefetch" href="/assets/js/23.ad7d0350.js"><link rel="prefetch" href="/assets/js/24.8559c4c3.js"><link rel="prefetch" href="/assets/js/25.783a8116.js"><link rel="prefetch" href="/assets/js/26.25e0e459.js"><link rel="prefetch" href="/assets/js/27.c0616e2a.js"><link rel="prefetch" href="/assets/js/28.30656c2e.js"><link rel="prefetch" href="/assets/js/29.2be5114c.js"><link rel="prefetch" href="/assets/js/3.be8c8f3b.js"><link rel="prefetch" href="/assets/js/30.230a74a7.js"><link rel="prefetch" href="/assets/js/31.760f46ad.js"><link rel="prefetch" href="/assets/js/32.c9533fef.js"><link rel="prefetch" href="/assets/js/33.dcacfb38.js"><link rel="prefetch" href="/assets/js/34.4370a466.js"><link rel="prefetch" href="/assets/js/35.bf299eea.js"><link rel="prefetch" href="/assets/js/36.336e435a.js"><link rel="prefetch" href="/assets/js/37.1d1d2eea.js"><link rel="prefetch" href="/assets/js/38.0d58b7d0.js"><link rel="prefetch" href="/assets/js/39.d43564ba.js"><link rel="prefetch" href="/assets/js/4.4a6cb970.js"><link rel="prefetch" href="/assets/js/40.bc4e4bde.js"><link rel="prefetch" href="/assets/js/41.b71231a5.js"><link rel="prefetch" href="/assets/js/42.9d46f400.js"><link rel="prefetch" href="/assets/js/43.50c5be69.js"><link rel="prefetch" href="/assets/js/44.60406e7f.js"><link rel="prefetch" href="/assets/js/45.ec3569ae.js"><link rel="prefetch" href="/assets/js/46.1bd3ce7b.js"><link rel="prefetch" href="/assets/js/47.1e1b5326.js"><link rel="prefetch" href="/assets/js/48.64c631ea.js"><link rel="prefetch" href="/assets/js/49.b4abacd8.js"><link rel="prefetch" href="/assets/js/5.e6d0b165.js"><link rel="prefetch" href="/assets/js/50.c3e320c0.js"><link rel="prefetch" href="/assets/js/51.5ec7fb8c.js"><link rel="prefetch" href="/assets/js/52.2d234f86.js"><link rel="prefetch" href="/assets/js/53.f3b69623.js"><link rel="prefetch" href="/assets/js/54.c85ff450.js"><link rel="prefetch" href="/assets/js/55.b07597b5.js"><link rel="prefetch" href="/assets/js/56.444129cf.js"><link rel="prefetch" href="/assets/js/57.df1329ba.js"><link rel="prefetch" href="/assets/js/59.d98936d9.js"><link rel="prefetch" href="/assets/js/6.809376cd.js"><link rel="prefetch" href="/assets/js/60.02813ecf.js"><link rel="prefetch" href="/assets/js/61.37a4812d.js"><link rel="prefetch" href="/assets/js/62.5da94048.js"><link rel="prefetch" href="/assets/js/63.8e2c2bca.js"><link rel="prefetch" href="/assets/js/64.d290398f.js"><link rel="prefetch" href="/assets/js/65.44e28313.js"><link rel="prefetch" href="/assets/js/66.9acf0206.js"><link rel="prefetch" href="/assets/js/67.85688aa2.js"><link rel="prefetch" href="/assets/js/68.45bda7fc.js"><link rel="prefetch" href="/assets/js/69.9074feb0.js"><link rel="prefetch" href="/assets/js/7.5d7bce6e.js"><link rel="prefetch" href="/assets/js/70.b4cd2ddc.js"><link rel="prefetch" href="/assets/js/71.53219b13.js"><link rel="prefetch" href="/assets/js/72.af2a7290.js"><link rel="prefetch" href="/assets/js/73.c28fc506.js"><link rel="prefetch" href="/assets/js/74.64c81a90.js"><link rel="prefetch" href="/assets/js/75.05191ece.js"><link rel="prefetch" href="/assets/js/76.f516d464.js"><link rel="prefetch" href="/assets/js/77.c345180b.js"><link rel="prefetch" href="/assets/js/78.4a09d0ba.js"><link rel="prefetch" href="/assets/js/79.65f41bcf.js"><link rel="prefetch" href="/assets/js/8.f6cfdc07.js"><link rel="prefetch" href="/assets/js/80.b77151f3.js"><link rel="prefetch" href="/assets/js/81.824fa371.js"><link rel="prefetch" href="/assets/js/82.3f91c09b.js"><link rel="prefetch" href="/assets/js/83.9539f074.js"><link rel="prefetch" href="/assets/js/84.dd89f1de.js"><link rel="prefetch" href="/assets/js/85.15210b99.js"><link rel="prefetch" href="/assets/js/86.e14553e1.js"><link rel="prefetch" href="/assets/js/87.6dc95177.js"><link rel="prefetch" href="/assets/js/88.09c5e890.js"><link rel="prefetch" href="/assets/js/89.0d61f4d0.js"><link rel="prefetch" href="/assets/js/9.759f1986.js"><link rel="prefetch" href="/assets/js/90.a9b14d80.js"><link rel="prefetch" href="/assets/js/91.1a4aabe2.js"><link rel="prefetch" href="/assets/js/92.12070bdb.js"><link rel="prefetch" href="/assets/js/93.b5dc76d0.js"><link rel="prefetch" href="/assets/js/94.690498a6.js"><link rel="prefetch" href="/assets/js/95.b17961e6.js"><link rel="prefetch" href="/assets/js/96.a2f06f3e.js"><link rel="prefetch" href="/assets/js/97.64ef6721.js"><link rel="prefetch" href="/assets/js/98.443eba26.js"><link rel="prefetch" href="/assets/js/99.b6ba7c3a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">MSG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python文档" class="dropdown-title"><span class="title">Python文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="Python文档" class="mobile-dropdown-title"><span class="title">Python文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Python/1.Python-Basics/" class="nav-link">
  Python-基础
</a></li><li class="dropdown-item"><!----> <a href="/Python/2. Python-object/" class="nav-link">
  Python-面向对象
</a></li><li class="dropdown-item"><!----> <a href="/Python/3. Python-module/" class="nav-link">
  Python-模块与包
</a></li><li class="dropdown-item"><!----> <a href="/Python/4. Python-network/" class="nav-link">
  Python-网络
</a></li><li class="dropdown-item"><!----> <a href="/Python/5. Python-frontend/" class="nav-link">
  Python-前端
</a></li><li class="dropdown-item"><!----> <a href="/Python/6. Python-MySQL/" class="nav-link">
  Python-数据库
</a></li><li class="dropdown-item"><!----> <a href="/Python/7. Python-Django/" class="nav-link">
  Python-Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="容器文档" class="dropdown-title"><span class="title">容器文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="容器文档" class="mobile-dropdown-title"><span class="title">容器文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Container/docker/" class="nav-link">
  docker文檔
</a></li><li class="dropdown-item"><!----> <a href="/Container/Kubernetes/" class="nav-link">
  Kubernetes文檔
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GO文档" class="dropdown-title"><span class="title">GO文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="GO文档" class="mobile-dropdown-title"><span class="title">GO文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/GO/basics/" class="nav-link">
  GO快速入门
</a></li><li class="dropdown-item"><!----> <a href="/GO/module/" class="nav-link router-link-active">
  GO标准库/GO模块
</a></li></ul></div></div><div class="nav-item"><a href="https://www.linux91.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python文档" class="dropdown-title"><span class="title">Python文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="Python文档" class="mobile-dropdown-title"><span class="title">Python文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Python/1.Python-Basics/" class="nav-link">
  Python-基础
</a></li><li class="dropdown-item"><!----> <a href="/Python/2. Python-object/" class="nav-link">
  Python-面向对象
</a></li><li class="dropdown-item"><!----> <a href="/Python/3. Python-module/" class="nav-link">
  Python-模块与包
</a></li><li class="dropdown-item"><!----> <a href="/Python/4. Python-network/" class="nav-link">
  Python-网络
</a></li><li class="dropdown-item"><!----> <a href="/Python/5. Python-frontend/" class="nav-link">
  Python-前端
</a></li><li class="dropdown-item"><!----> <a href="/Python/6. Python-MySQL/" class="nav-link">
  Python-数据库
</a></li><li class="dropdown-item"><!----> <a href="/Python/7. Python-Django/" class="nav-link">
  Python-Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="容器文档" class="dropdown-title"><span class="title">容器文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="容器文档" class="mobile-dropdown-title"><span class="title">容器文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Container/docker/" class="nav-link">
  docker文檔
</a></li><li class="dropdown-item"><!----> <a href="/Container/Kubernetes/" class="nav-link">
  Kubernetes文檔
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GO文档" class="dropdown-title"><span class="title">GO文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="GO文档" class="mobile-dropdown-title"><span class="title">GO文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/GO/basics/" class="nav-link">
  GO快速入门
</a></li><li class="dropdown-item"><!----> <a href="/GO/module/" class="nav-link router-link-active">
  GO标准库/GO模块
</a></li></ul></div></div><div class="nav-item"><a href="https://www.linux91.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>GO标准库/GO模块</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/GO/module/" aria-current="page" class="sidebar-link">介绍</a></li><li><a href="/GO/module/http - nethttp包.html" class="sidebar-link">http - net/http包</a></li><li><a href="/GO/module/math-基本数学函数-.-不用.html" class="sidebar-link">math-基本数学函数-.-不用</a></li><li><a href="/GO/module/命令行参数分析-flag包.html" class="sidebar-link">命令行参数分析-flag包</a></li><li><a href="/GO/module/字符串操作 - strings包.html" class="sidebar-link">字符串操作 - strings包</a></li><li><a href="/GO/module/并发 - Context包.html" class="sidebar-link">并发 - Context包</a></li><li><a href="/GO/module/库大全.html" class="sidebar-link">库大全</a></li><li><a href="/GO/module/数据类型转换.html" class="sidebar-link">数据类型转换</a></li><li><a href="/GO/module/文本操作 - unicode.html" class="sidebar-link">文本操作 - unicode</a></li><li><a href="/GO/module/日志 - log包.html" class="sidebar-link">日志 - log包</a></li><li><a href="/GO/module/时间 - Local时区.html" class="sidebar-link">时间 -  Local时区</a></li><li><a href="/GO/module/时间 - time.html" class="sidebar-link">时间 -  time</a></li><li><a href="/GO/module/时间 - 定时器.html" class="sidebar-link">时间 - 定时器</a></li><li><a href="/GO/module/输出输入 - fmt包.html" class="sidebar-link">输出输入 - fmt包</a></li><li><a href="/GO/module/输出输入 - IO包.html" class="sidebar-link">输出输入 -  IO包</a></li><li><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html" class="active sidebar-link">输出输入 - 缓存IO包-bufio - 原文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-1-reader-类型和方法" class="sidebar-link">1.4.1 Reader 类型和方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-1-1-实例化" class="sidebar-link">1.4.1.1 实例化</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-1-2-readslice、readbytes、readstring-和-readline-方法" class="sidebar-link">1.4.1.2 ReadSlice、ReadBytes、ReadString 和 ReadLine 方法</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-1-3-peek-方法" class="sidebar-link">1.4.1.3 Peek 方法</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-1-4-其他方法" class="sidebar-link">1.4.1.4 其他方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-2-scanner-类型和方法" class="sidebar-link">1.4.2 Scanner 类型和方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-2-1-splitfunc-类型和实例" class="sidebar-link">1.4.2.1 SplitFunc 类型和实例</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-2-2-scanner-的实例化" class="sidebar-link">1.4.2.2 Scanner 的实例化</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-2-2-scanner-的方法" class="sidebar-link">1.4.2.2 Scanner 的方法</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-2-3-scanner-使用示例" class="sidebar-link">1.4.2.3 Scanner 使用示例</a></li></ul></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-3-writer-类型和方法" class="sidebar-link">1.4.3 Writer 类型和方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-3-1-实例化" class="sidebar-link">1.4.3.1 实例化</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-3-2-available-和-buffered-方法" class="sidebar-link">1.4.3.2 Available 和 Buffered 方法</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-3-3-flush-方法" class="sidebar-link">1.4.3.3 Flush 方法</a></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-3-4-其他方法" class="sidebar-link">1.4.3.4 其他方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/GO/module/输出输入 - 缓存IO包-bufio - 原文.html#_1-4-4-readwriter-类型和实例化" class="sidebar-link">1.4.4 ReadWriter 类型和实例化</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="输出输入-缓存io包-bufio-原文"><a href="#输出输入-缓存io包-bufio-原文" class="header-anchor">#</a> 输出输入 - 缓存IO包-bufio - 原文</h1> <h1 id="bufio-缓存-io"><a href="#bufio-缓存-io" class="header-anchor">#</a> bufio — 缓存 IO</h1> <p>bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。</p> <h2 id="_1-4-1-reader-类型和方法"><a href="#_1-4-1-reader-类型和方法" class="header-anchor">#</a> 1.4.1 Reader 类型和方法</h2> <p>bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。</p> <p>Reader 结构没有任何导出的字段，结构定义如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">type</span> Reader <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        buf          <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>        <span class="token comment">// 缓存</span>
        rd           io<span class="token punctuation">.</span>Reader    <span class="token comment">// 底层的io.Reader</span>
        <span class="token comment">// r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移；</span>
        <span class="token comment">// w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值</span>
        r<span class="token punctuation">,</span> w         <span class="token builtin">int</span>
        err          <span class="token builtin">error</span>        <span class="token comment">// 读过程中遇到的错误</span>
        lastByte     <span class="token builtin">int</span>        <span class="token comment">// 最后一次读到的字节（ReadByte/UnreadByte)</span>
        lastRuneSize <span class="token builtin">int</span>        <span class="token comment">// 最后一次读到的Rune的大小 (ReadRune/UnreadRune)</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-4-1-1-实例化"><a href="#_1-4-1-1-实例化" class="header-anchor">#</a> 1.4.1.1 实例化</h3> <p>bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">NewReader</span><span class="token punctuation">(</span>rd io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token operator">*</span>Reader <span class="token punctuation">{</span>
        <span class="token comment">// 默认缓存大小：defaultBufSize=4096</span>
        <span class="token keyword">return</span> <span class="token function">NewReaderSize</span><span class="token punctuation">(</span>rd<span class="token punctuation">,</span> defaultBufSize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们看一下NewReaderSize的源码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">NewReaderSize</span><span class="token punctuation">(</span>rd io<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Reader <span class="token punctuation">{</span>
        <span class="token comment">// 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回</span>
        b<span class="token punctuation">,</span> ok <span class="token operator">:=</span> rd<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Reader<span class="token punctuation">)</span>
        <span class="token keyword">if</span> ok <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size <span class="token punctuation">{</span>
            <span class="token keyword">return</span> b
        <span class="token punctuation">}</span>
        <span class="token comment">// 缓存大小不会小于 minReadBufferSize （16字节）</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> minReadBufferSize <span class="token punctuation">{</span>
            size <span class="token operator">=</span> minReadBufferSize
        <span class="token punctuation">}</span>
        <span class="token comment">// 构造一个bufio.Reader实例</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>Reader<span class="token punctuation">{</span>
            buf<span class="token punctuation">:</span>          <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span>
            rd<span class="token punctuation">:</span>           rd<span class="token punctuation">,</span>
            lastByte<span class="token punctuation">:</span>     <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
            lastRuneSize<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-4-1-2-readslice、readbytes、readstring-和-readline-方法"><a href="#_1-4-1-2-readslice、readbytes、readstring-和-readline-方法" class="header-anchor">#</a> 1.4.1.2 ReadSlice、ReadBytes、ReadString 和 ReadLine 方法</h3> <p>之所以将这几个方法放在一起，是因为他们有着类似的行为。事实上，后三个方法最终都是调用ReadSlice来实现的。所以，我们先来看看ReadSlice方法。(感觉这一段直接看源码较好)</p> <p><strong>ReadSlice方法签名</strong>如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadSlice</span><span class="token punctuation">(</span>delim <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>line <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>ReadSlice 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 slice，在下次调用读操作（read）时，这些字节会无效。举例说明：</p> <div class="language-go extra-class"><pre class="language-go"><code>    reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadSlice</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;the line:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
    <span class="token comment">// 这里可以换上任意的 bufio 的 Read/Write 操作</span>
    n<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadSlice</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;the line:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    the line:http://studygolang.com. 

    the line:It is the home of gophers
    It is the home of gophers
</code></pre></div><p>从结果可以看出，第一次ReadSlice的结果（line），在第二次调用读操作后，内容发生了变化。也就是说，ReadSlice 返回的 []byte 是指向 Reader 中的 buffer ，而不是 copy 一份返回。正因为ReadSlice 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择使用 ReadBytes 或者 ReadString 来代替。读者可以将上面代码中的 ReadSlice 改为 ReadBytes 或 ReadString ，看看结果有什么不同。</p> <p>注意，这里的界定符可以是任意的字符，可以将上面代码中的’\n’改为’m’试试。同时，返回的结果是包含界定符本身的，上例中，输出结果有一空行就是’\n’本身(line携带一个’\n’,printf又追加了一个’\n’)。</p> <p>如果 ReadSlice 在找到界定符之前遇到了 error ，它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。如果在找到界定符之前缓存已经满了，ReadSlice 会返回 bufio.ErrBufferFull 错误。当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice 返回err != nil，也就是说，如果ReadSlice 返回的结果 line 不是以界定符 delim 结尾，那么返回的 er r也一定不等于 nil（可能是bufio.ErrBufferFull或io.EOF）。
例子代码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReaderSize</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadSlice</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;line:%s\terror:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> err <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">ReadSlice</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;line:%s\terror:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
</code></pre></div><p>输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    line:http://studygola    error:bufio: buffer full
    line:ng.com    error:EOF
</code></pre></div><p><strong>ReadBytes方法签名</strong>如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadBytes</span><span class="token punctuation">(</span>delim <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>line <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>该方法的参数和返回值类型与 ReadSlice 都一样。 ReadBytes 从输入中读取直到遇到界定符（delim）为止，返回的 slice 包含了从当前到界定符的内容 <strong>（包括界定符）</strong>。如果 ReadBytes 在遇到界定符之前就捕获到一个错误，它会返回遇到错误之前已经读取的数据，和这个捕获到的错误（经常是 io.EOF）。跟 ReadSlice 一样，如果 ReadBytes 返回的结果 line 不是以界定符 delim 结尾，那么返回的 err 也一定不等于 nil（可能是bufio.ErrBufferFull 或 io.EOF）。</p> <p>从这个说明可以看出，ReadBytes和ReadSlice功能和用法都很像，那他们有什么不同呢？</p> <p>在讲解ReadSlice时说到，它返回的 []byte 是指向 Reader 中的 buffer，而不是 copy 一份返回，也正因为如此，通常我们会使用 ReadBytes 或 ReadString。很显然，ReadBytes 返回的 []byte 不会是指向 Reader 中的 buffer，通过<a href="http://docscn.studygolang.com/src/bufio/bufio.go?s=10277:10340#L338" target="_blank" rel="noopener noreferrer">查看源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>可以证实这一点。</p> <p>还是上面的例子，我们将 ReadSlice 改为 ReadBytes：</p> <div class="language-go extra-class"><pre class="language-go"><code>    reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    line<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;the line:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
    <span class="token comment">// 这里可以换上任意的 bufio 的 Read/Write 操作</span>
    n<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;the line:%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    the line:http://studygolang.com. 

    the line:http://studygolang.com. 

    It is the home of gophers
</code></pre></div><p><strong>ReadString方法</strong></p> <p>看一下该方法的源码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadString</span><span class="token punctuation">(</span>delim <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>line <span class="token builtin">string</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bytes<span class="token punctuation">,</span> err <span class="token operator">:=</span> b<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span>delim<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
</code></pre></div><p>它调用了 ReadBytes 方法，并将结果的 []byte 转为 string 类型。</p> <p><strong>ReadLine方法签名</strong>如下</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>line <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> isPrefix <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>ReadLine 是一个底层的原始行读取命令。许多调用者或许会使用 ReadBytes(‘\n’) 或者 ReadString(‘\n’) 来代替这个方法。</p> <p>ReadLine 尝试返回单独的行，不包括行尾的换行符。如果一行大于缓存，isPrefix 会被设置为 true，同时返回该行的开始部分（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，isPrefix 将会是 false 。跟 ReadSlice 一样，返回的 line 只是 buffer 的引用，在下次执行IO操作时，line 会无效。可以将 ReadSlice 中的例子该为 ReadLine 试试。</p> <p>注意，返回值中，要么 line 不是 nil，要么 err 非 nil，两者不会同时非 nil。</p> <p>ReadLine 返回的文本不会包含行结尾（”\r\n”或者”\n”）。如果输入中没有行尾标识符，不会返回任何指示或者错误。</p> <p>从上面的讲解中，我们知道，读取一行，通常会选择 ReadBytes 或 ReadString。不过，正常人的思维，应该用 ReadLine，只是不明白为啥 ReadLine 的实现不是通过 ReadBytes，然后清除掉行尾的\n（或\r\n），它现在的实现，用不好会出现意想不到的问题，比如丢数据。个人建议可以这么实现读取一行：</p> <div class="language-go extra-class"><pre class="language-go"><code>    line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
    line <span class="token operator">=</span> bytes<span class="token punctuation">.</span><span class="token function">TrimRight</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token string">&quot;\r\n&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。</p> <h3 id="_1-4-1-3-peek-方法"><a href="#_1-4-1-3-peek-方法" class="header-anchor">#</a> 1.4.1.3 Peek 方法</h3> <p>从方法的名称可以猜到，该方法只是“窥探”一下 Reader 中没有读取的 n 个字节。好比栈数据结构中的取栈顶元素，但不出栈。</p> <p>方法的签名如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">Peek</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>同上面介绍的 ReadSlice一样，返回的 []byte 只是 buffer 中的引用，在下次IO操作后会无效，可见该方法（以及ReadSlice这样的，返回buffer引用的方法）对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。</p> <p>我们通过例子来证明一下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">package</span> main

    <span class="token keyword">import</span> <span class="token punctuation">(</span>
        <span class="token string">&quot;bufio&quot;</span>
        <span class="token string">&quot;fmt&quot;</span>
        <span class="token string">&quot;strings&quot;</span>
        <span class="token string">&quot;time&quot;</span>
    <span class="token punctuation">)</span>

    <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReaderSize</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com.\t It is the home of gophers&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token function">Peek</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span>
        <span class="token keyword">go</span> reader<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1e8</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">Peek</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        line<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
        <span class="token comment">// time.Sleep(1)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    http://studygo
    http://studygo
</code></pre></div><p>输出结果和预期的一致。然而，这是由于目前的 goroutine 调度方式导致的结果。如果我们将例子中注释掉的 time.Sleep(1) 取消注释（这样调度其他 goroutine 执行），再次运行，得到的结果为：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    http://studygo
    ng.com.     It is
</code></pre></div><p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p> <h3 id="_1-4-1-4-其他方法"><a href="#_1-4-1-4-其他方法" class="header-anchor">#</a> 1.4.1.4 其他方法</h3> <p>Reader 的其他方法都是实现了 io 包中的接口，它们的使用方法在io包中都有介绍，在此不赘述。</p> <p>这些方法包括：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c <span class="token builtin">byte</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">ReadRune</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">UnreadByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">UnreadRune</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Reader<span class="token punctuation">)</span> <span class="token function">WriteTo</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>你应该知道它们都是哪个接口的方法吧。</p> <h2 id="_1-4-2-scanner-类型和方法"><a href="#_1-4-2-scanner-类型和方法" class="header-anchor">#</a> 1.4.2 Scanner 类型和方法</h2> <p>对于简单的读取一行，在 Reader 类型中，感觉没有让人特别满意的方法。于是，Go1.1增加了一个类型：Scanner。官方关于<strong>Go1.1</strong>增加该类型的说明如下：</p> <blockquote><p>在 bufio 包中有多种方式获取文本输入，ReadBytes、ReadString 和独特的 ReadLine，对于简单的目的这些都有些过于复杂了。在 Go 1.1 中，添加了一个新类型，Scanner，以便更容易的处理如按行读取输入序列或空格分隔单词等，这类简单的任务。它终结了如输入一个很长的有问题的行这样的输入错误，并且提供了简单的默认行为：基于行的输入，每行都剔除分隔标识。这里的代码展示一次输入一行：</p> <div class="language-go extra-class"><pre class="language-go"><code>    scanner <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
    <span class="token keyword">for</span> scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Println will add back the final '\n'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> scanner<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">&quot;reading standard input:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>输入的行为可以通过一个函数控制，来控制输入的每个部分（参阅 SplitFunc 的文档），但是对于复杂的问题或持续传递错误的，可能还是需要原有接口。</p></blockquote> <p>Scanner 类型和 Reader 类型一样，没有任何导出的字段，同时它也包装了一个 io.Reader 对象，但它没有实现 io.Reader 接口。</p> <p>Scanner 的结构定义如下：</p> <div class="language- extra-class"><pre class="language-text"><code>type Scanner struct {
    r            io.Reader // The reader provided by the client.
    split        SplitFunc // The function to split the tokens.
    maxTokenSize int       // Maximum size of a token; modified by tests.
    token        []byte    // Last token returned by split.
    buf          []byte    // Buffer used as argument to split.
    start        int       // First non-processed byte in buf.
    end          int       // End of data in buf.
    err          error     // Sticky error.
}
</code></pre></div><p>这里 split、maxTokenSize 和 token 需要讲解一下。</p> <p>然而，在讲解之前，需要先讲解 split 字段的类型 SplitFunc。</p> <h3 id="_1-4-2-1-splitfunc-类型和实例"><a href="#_1-4-2-1-splitfunc-类型和实例" class="header-anchor">#</a> 1.4.2.1 SplitFunc 类型和实例</h3> <p><strong>SplitFunc 类型定义</strong>如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">type</span> SplitFunc <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> atEOF <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>advance <span class="token builtin">int</span><span class="token punctuation">,</span> token <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>SplitFunc 定义了 用于对输入进行分词的 split 函数的签名。参数 data 是还未处理的数据，atEOF 标识 Reader 是否还有更多数据（是否到了EOF）。返回值 advance 表示从输入中读取的字节数，token 表示下一个结果数据，err 则代表可能的错误。</p> <p>举例说明一下这里的 token 代表的意思：</p> <div class="language- extra-class"><pre class="language-text"><code>有数据 &quot;studygolang\tpolaris\tgolangchina&quot;，通过&quot;\t&quot;进行分词，那么会得到三个token，它们的内容分别是：studygolang、polaris 和 golangchina。而 SplitFunc 的功能是：进行分词，并返回未处理的数据中第一个 token。对于这个数据，就是返回 studygolang。
</code></pre></div><p>如果 data 中没有一个完整的 token，例如，在扫描行（scanning lines）时没有换行符，SplitFunc 会返回(0,nil,nil)通知 Scanner 读取更多数据到 slice 中，然后在这个更大的 slice 中同样的读取点处，从输入中重试读取。如下面要讲解的 split 函数的源码中有这样的代码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token comment">// Request more data.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
</code></pre></div><p>如果 <code>err != nil</code>，扫描停止，同时该错误会返回。</p> <p>如果参数 data 为空的 slice，除非 atEOF 为 true，否则该函数永远不会被调用。如果 atEOF 为 true，这时 data 可以非空，这时的数据是没有处理的。</p> <p><strong>bufio 包定义的 split 函数，即 SplitFunc 的实例</strong></p> <p>在 bufio 包中预定义了一些 split 函数，也就是说，在 Scanner 结构中的 split 字段，可以通过这些预定义的 split 赋值，同时 Scanner 类型的 Split 方法也可以接收这些预定义函数作为参数。所以，我们可以说，这些预定义 split 函数都是 SplitFunc 类型的实例。这些函数包括：ScanBytes、ScanRunes、ScanWords 和 ScanLines。（由于都是 SplitFunc 的实例，自然这些函数的签名都和 SplitFunc 一样）</p> <p><strong>ScanBytes</strong> 返回单个字节作为一个 token。</p> <p><strong>ScanRunes</strong> 返回单个 UTF-8 编码的 rune 作为一个 token。返回的 rune 序列（token）和 range string类型 返回的序列是等价的，也就是说，对于无效的 UTF-8 编码会解释为 U+FFFD = “\xef\xbf\xbd”。</p> <p><strong>ScanWords</strong> 返回通过“空格”分词的单词。如：study golang，调用会返回study。注意，这里的“空格”是 <code>unicode.IsSpace()</code>，即包括：’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)。</p> <p><strong>ScanLines</strong> 返回一行文本，不包括行尾的换行符。这里的换行包括了Windows下的”\r\n”和Unix下的”\n”。</p> <p>一般地，我们不会单独使用这些函数，而是提供给 Scanner 实例使用。现在我们回到 Scanner 的 split、maxTokenSize 和 token 字段上来。</p> <p><strong>split 字段</strong>（SplitFunc 类型实例），很显然，代表了当前 Scanner 使用的分词策略，可以使用上面介绍的预定义 SplitFunc 实例赋值，也可以自定义 SplitFunc 实例。（当然，要给 split 字段赋值，必须调用 Scanner 的 Split 方法）</p> <p><strong>maxTokenSize 字段</strong> 表示通过 split 分词后的一个 token 允许的最大长度。在该包中定义了一个常量 MaxScanTokenSize = 64 * 1024，这是允许的最大 token 长度（64k）。</p> <p><strong>token 字段</strong> 上文已经解释了这个是什么意思。</p> <h3 id="_1-4-2-2-scanner-的实例化"><a href="#_1-4-2-2-scanner-的实例化" class="header-anchor">#</a> 1.4.2.2 Scanner 的实例化</h3> <p>Scanner 没有导出任何字段，而它需要有外部的 io.Reader 对象，因此，我们不能直接实例化 Scanner 对象，必须通过 bufio 包提供的实例化函数来实例化。实例化函数签名以及内部实现：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">NewScanner</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token operator">*</span>Scanner <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>Scanner<span class="token punctuation">{</span>
            r<span class="token punctuation">:</span>            r<span class="token punctuation">,</span>
            split<span class="token punctuation">:</span>        ScanLines<span class="token punctuation">,</span>
            maxTokenSize<span class="token punctuation">:</span> MaxScanTokenSize<span class="token punctuation">,</span>
            buf<span class="token punctuation">:</span>          <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// Plausible starting size; needn't be large.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>可见，返回的 Scanner 实例默认的 split 函数是 ScanLines。</p> <h3 id="_1-4-2-2-scanner-的方法"><a href="#_1-4-2-2-scanner-的方法" class="header-anchor">#</a> 1.4.2.2 Scanner 的方法</h3> <p><strong>Split 方法</strong> 前面我们提到过可以通过 Split 方法为 Scanner 实例设置分词行为。由于 Scanner 实例的默认 split 总是 ScanLines，如果我们想要用其他的 split，可以通过 Split 方法做到。</p> <p>比如，我们想要统计一段英文有多少个单词（不排除重复），我们可以这么做：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token string">&quot;This is The Golang Standard Library.\nWelcome you!&quot;</span>
    scanner <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span>
    scanner<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span>ScanWords<span class="token punctuation">)</span>
    count <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> scanner<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">&quot;reading input:&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
</code></pre></div><p>输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    <span class="token number">8</span>
</code></pre></div><p>我们实例化 Scanner 后，通过调用 scanner.Split(bufio.ScanWords) 来更改 split 函数。注意，我们应该在调用 Scan 方法之前调用 Split 方法。</p> <p><strong>Scan 方法</strong> 该方法好比 iterator 中的 Next 方法，它用于将 Scanner 获取下一个 token，以便 Bytes 和 Text 方法可用。当扫描停止时，它返回false，这时候，要么是到了输入的末尾要么是遇到了一个错误。注意，当 Scan 返回 false 时，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。</p> <p><strong>Bytes 和 Text 方法</strong> 这两个方法的行为一致，都是返回最近的 token，无非 Bytes 返回的是 []byte，Text 返回的是 string。该方法应该在 Scan 调用后调用，而且，下次调用 Scan 会覆盖这次的 token。比如：</p> <div class="language-go extra-class"><pre class="language-go"><code>    scanner <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> scanner<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>返回的是：<code>It is the home of gophers</code> 而不是 <code>http://studygolang.com.</code></p> <p><strong>Err 方法</strong> 前面已经提到，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。</p> <p>下面，我们通过一个完整的示例来演示 Scanner 类型的使用。</p> <h3 id="_1-4-2-3-scanner-使用示例"><a href="#_1-4-2-3-scanner-使用示例" class="header-anchor">#</a> 1.4.2.3 Scanner 使用示例</h3> <p>我们经常会有这样的需求：读取文件中的数据，一次读取一行。在学习了 Reader 类型，我们可以使用它的 ReadBytes 或 ReadString来实现，甚至使用 ReadLine 来实现。然而，在 Go1.1 中，我们可以使用 Scanner 来做这件事，而且更简单好用。</p> <div class="language-go extra-class"><pre class="language-go"><code>    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">&quot;scanner.txt&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    file<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">&quot;http://studygolang.com.\nIt is the home of gophers.\nIf you are studying golang, welcome you!&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 将文件 offset 设置到文件开头</span>
    file<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>SEEK_SET<span class="token punctuation">)</span>
    scanner <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
    <span class="token keyword">for</span> scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>输出结果：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    http://studygolang.com.
    It is the home of gophers.
    If you are studying golang, welcome you<span class="token operator">!</span>
</code></pre></div><h2 id="_1-4-3-writer-类型和方法"><a href="#_1-4-3-writer-类型和方法" class="header-anchor">#</a> 1.4.3 Writer 类型和方法</h2> <p>bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。</p> <p>Writer 结构没有任何导出的字段，结构定义如下：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">type</span> Writer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        err <span class="token builtin">error</span>        <span class="token comment">// 写过程中遇到的错误</span>
        buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>        <span class="token comment">// 缓存</span>
        n   <span class="token builtin">int</span>            <span class="token comment">// 当前缓存中的字节数</span>
        wr  io<span class="token punctuation">.</span>Writer    <span class="token comment">// 底层的 io.Writer 对象</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>相比 bufio.Reader, bufio.Writer 结构定义简单很多。</p> <p>注意：如果在写数据到 Writer 的时候出现了一个错误，不会再允许有数据被写进来了，并且所有随后的写操作都会返回该错误。</p> <h3 id="_1-4-3-1-实例化"><a href="#_1-4-3-1-实例化" class="header-anchor">#</a> 1.4.3.1 实例化</h3> <p>和 Reader 类型一样，bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">NewWriter</span><span class="token punctuation">(</span>wr io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token operator">*</span>Writer <span class="token punctuation">{</span>
        <span class="token comment">// 默认缓存大小：defaultBufSize=4096</span>
        <span class="token keyword">return</span> <span class="token function">NewWriterSize</span><span class="token punctuation">(</span>wr<span class="token punctuation">,</span> defaultBufSize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们看一下 NewWriterSize 的源码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">func</span> <span class="token function">NewWriterSize</span><span class="token punctuation">(</span>wr io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Writer <span class="token punctuation">{</span>
        <span class="token comment">// 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回</span>
        b<span class="token punctuation">,</span> ok <span class="token operator">:=</span> wr<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Writer<span class="token punctuation">)</span>
        <span class="token keyword">if</span> ok <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>buf<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size <span class="token punctuation">{</span>
            <span class="token keyword">return</span> b
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            size <span class="token operator">=</span> defaultBufSize
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>Writer<span class="token punctuation">{</span>
            buf<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span>
            wr<span class="token punctuation">:</span>  w<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-4-3-2-available-和-buffered-方法"><a href="#_1-4-3-2-available-和-buffered-方法" class="header-anchor">#</a> 1.4.3.2 Available 和 Buffered 方法</h3> <p>Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；Buffered 方法获取写入当前缓存中的字节数（字段 n 的值）</p> <h3 id="_1-4-3-3-flush-方法"><a href="#_1-4-3-3-flush-方法" class="header-anchor">#</a> 1.4.3.3 Flush 方法</h3> <p>该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。</p> <h3 id="_1-4-3-4-其他方法"><a href="#_1-4-3-4-其他方法" class="header-anchor">#</a> 1.4.3.4 其他方法</h3> <p>Writer 类型其他方法是一些实际的写方法：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token comment">// 实现了 io.ReaderFrom 接口</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">ReadFrom</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

    <span class="token comment">// 实现了 io.Writer 接口</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nn <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

    <span class="token comment">// 实现了 io.ByteWriter 接口</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">WriteByte</span><span class="token punctuation">(</span>c <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">error</span>

    <span class="token comment">// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">WriteRune</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>size <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>

    <span class="token comment">// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因</span>
    <span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">WriteString</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre></div><p>这些写方法在缓存满了时会调用 Flush 方法。另外，这些写方法源码开始处，有这样的代码：</p> <div class="language-go extra-class"><pre class="language-go"><code>    <span class="token keyword">if</span> b<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span>err
    <span class="token punctuation">}</span>
</code></pre></div><p>也就是说，只要写的过程中遇到了错误，再次调用写操作会直接返回该错误。</p> <h2 id="_1-4-4-readwriter-类型和实例化"><a href="#_1-4-4-readwriter-类型和实例化" class="header-anchor">#</a> 1.4.4 ReadWriter 类型和实例化</h2> <p>ReadWriter 结构存储了 bufio.Reader 和 bufio.Writer 类型的指针（内嵌），它实现了 io.ReadWriter 结构。</p> <div class="language- extra-class"><pre class="language-text"><code>    type ReadWriter struct {
        *Reader
        *Writer
    }
</code></pre></div><p>ReadWriter 的实例化可以跟普通结构类型一样，也可以通过调用 bufio.NewReadWriter 函数来实现：只是简单的实例化 ReadWriter</p> <div class="language- extra-class"><pre class="language-text"><code>    func NewReadWriter(r *Reader, w *Writer) *ReadWriter {
        return &amp;ReadWriter{r, w}
    }
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/GO/module/输出输入 - IO包.html" class="prev">
        输出输入 -  IO包
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d65bef42.js" defer></script><script src="/assets/js/2.2249178e.js" defer></script><script src="/assets/js/58.5afb51cf.js" defer></script>
  </body>
</html>
