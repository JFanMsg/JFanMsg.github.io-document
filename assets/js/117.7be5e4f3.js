(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{481:function(_,v,l){"use strict";l.r(v);var i=l(45),t=Object(i.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h1",{attrs:{id:"_51-线程-理念知识"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_51-线程-理念知识"}},[_._v("#")]),_._v(" 51. 线程 - 理念知识")]),_._v(" "),l("h1",{attrs:{id:"操作系统线程-理论知识"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#操作系统线程-理论知识"}},[_._v("#")]),_._v(" 操作系统线程 - 理论知识")]),_._v(" "),l("h2",{attrs:{id:"线程概念的引入背景"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程概念的引入背景"}},[_._v("#")]),_._v(" 线程概念的引入背景")]),_._v(" "),l("p",[l("strong",[_._v("进程")]),_._v("\n　　之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。正是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。")]),_._v(" "),l("p",[l("strong",[_._v("进程这么牛逼，为什么还要有线程？")]),_._v("\n进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：")]),_._v(" "),l("ol",[l("li",[_._v("进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。")]),_._v(" "),l("li",[_._v("进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。")])]),_._v(" "),l("p",[_._v("如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。")]),_._v(" "),l("p",[_._v("现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。")]),_._v(" "),l("p",[l("strong",[_._v("线程的出现")]),_._v("\n60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。\n　　因此在80年代，出现了能独立运行的基本单位——线程（Threads）。\n　　注意：进程是资源分配的最小单位,线程是CPU调度的最小单位.\n　　　　　每一个进程中至少有一个线程")]),_._v(" "),l("p"),_._v(" "),l("p",[l("strong",[_._v("线程与进程的区别可以归纳为以下4点：")])]),_._v(" "),l("ol",[l("li",[_._v("地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。")]),_._v(" "),l("li",[_._v("通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。")]),_._v(" "),l("li",[_._v("调度和切换：线程上下文切换比进程上下文切换要快得多。")]),_._v(" "),l("li",[_._v("在多线程操作系统中，进程不是一个可执行的实体。")])]),_._v(" "),l("h2",{attrs:{id:"线程的特点"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的特点"}},[_._v("#")]),_._v(" "),l("strong",[_._v("线程的特点")])]),_._v(" "),l("p",[_._v("在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。")]),_._v(" "),l("ol",[l("li",[_._v("轻型实体：\n"),l("ol",[l("li",[_._v("线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。")]),_._v(" "),l("li",[_._v("线程的实体包括程序、数据和TCB。\n"),l("ol",[l("li",[_._v("线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。\n"),l("ol",[l("li",[_._v("TCB包括以下信息：\n"),l("ol",[l("li",[_._v("线程状态。")]),_._v(" "),l("li",[_._v("当线程不运行时，被保存的现场资源。")]),_._v(" "),l("li",[_._v("一组执行堆栈。")]),_._v(" "),l("li",[_._v("存放每个线程的局部变量主存区。")]),_._v(" "),l("li",[_._v("访问同一个进程中的主存和其它资源。")]),_._v(" "),l("li",[_._v("用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。")])])])])])])])])]),_._v(" "),l("li",[_._v("独立调度和分派的基本单位：\n"),l("ol",[l("li",[_._v("在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。")]),_._v(" "),l("li",[_._v("由于线程很轻，故线程的切换非常迅速且开销小（在同一进程中的）。")])])]),_._v(" "),l("li",[_._v("共享进程资源：\n"),l("ol",[l("li",[_._v("线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，")]),_._v(" "),l("li",[_._v("这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；")]),_._v(" "),l("li",[_._v("此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。")]),_._v(" "),l("li",[_._v("由于同一个进程内的线程共享内存和文件，所以"),l("strong",[_._v("线程之间互相通信不必调用内核")]),_._v("。")])])]),_._v(" "),l("li",[_._v("可并发执行：\n"),l("ol",[l("li",[_._v("在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力")])])])]),_._v(" "),l("h2",{attrs:{id:"使用线程的实际场景"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#使用线程的实际场景"}},[_._v("#")]),_._v(" 使用线程的实际场景")]),_._v(" "),l("p",[_._v("开启一个字处理软件进程，该进程肯定需要办不止一件事情，")]),_._v(" "),l("ol",[l("li",[_._v("比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，")]),_._v(" "),l("li",[_._v("那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。")])]),_._v(" "),l("h2",{attrs:{id:"内存中的线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#内存中的线程"}},[_._v("#")]),_._v(" 内存中的线程")]),_._v(" "),l("ol",[l("li",[_._v("多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。")]),_._v(" "),l("li",[_._v("而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也和多进程的运行类似，是cpu在多个线程之间的快速切换。")]),_._v(" "),l("li",[_._v("不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。")]),_._v(" "),l("li",[_._v("类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。")])]),_._v(" "),l("p"),_._v(" "),l("p",[l("strong",[_._v("线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：")])]),_._v(" "),l("p",[_._v("1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程\n　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？\n　　3. 因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。")]),_._v(" "),l("h2",{attrs:{id:"用户级线程和内核级线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#用户级线程和内核级线程"}},[_._v("#")]),_._v(" 用户级线程和内核级线程")]),_._v(" "),l("p",[_._v("线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。")]),_._v(" "),l("p",[l("strong",[_._v("用户级线程")])]),_._v(" "),l("ol",[l("li",[l("p",[_._v("内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。")])]),_._v(" "),l("li",[l("p",[_._v("在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。")])])]),_._v(" "),l("p",[l("strong",[_._v("内核级线程")])]),_._v(" "),l("ol",[l("li",[_._v("内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的")])]),_._v(" "),l("p",[l("strong",[_._v("用户级线程和内核级线程的区别")])]),_._v(" "),l("ol",[l("li",[_._v("内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。")]),_._v(" "),l("li",[_._v("用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。")]),_._v(" "),l("li",[_._v("用户级线程执行系统调用指令时将导致其"),l("strong",[_._v("所属进程")]),_._v("被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。")]),_._v(" "),l("li",[_._v("在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。")]),_._v(" "),l("li",[_._v("用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。")])]),_._v(" "),l("p",[_._v("**内核线程的优缺点 **")]),_._v(" "),l("ol",[l("li",[_._v("优点：当有多个处理机时，一个进程的多个线程可以同时执行。")]),_._v(" "),l("li",[_._v("缺点：由内核进行调度。")])]),_._v(" "),l("p",[_._v("**用户级线程的优缺点 **")]),_._v(" "),l("ol",[l("li",[_._v("优点：线程的调度不需要内核直接参与，控制简单。\n"),l("ol",[l("li",[_._v("可以在不支持线程的操作系统中实现。")]),_._v(" "),l("li",[_._v("创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。")]),_._v(" "),l("li",[_._v("允许每个进程定制自己的调度算法，线程管理比较灵活。")]),_._v(" "),l("li",[_._v("线程能够利用的表空间和堆栈空间比内核级线程多。")]),_._v(" "),l("li",[_._v("同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。")])])]),_._v(" "),l("li",[_._v("缺点：资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用")])]),_._v(" "),l("p",[l("strong",[_._v("混合实现")])]),_._v(" "),l("p",[_._v("用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程")]),_._v(" "),l("ol",[l("li",[l("p",[_._v("历史：")]),_._v(" "),l("ol",[l("li",[_._v("在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。LinuxThread就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循POSIX标准，特别是在信号处理，调度，进程间通信原语等方面。")]),_._v(" "),l("li",[_._v("很显然，为了改进LinuxThread必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及Redhat公司的NPTL。在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。")]),_._v(" "),l("li",[_._v("NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。")])])]),_._v(" "),l("li",[l("p",[_._v("设计：")]),_._v(" "),l("ol",[l("li",[_._v("NPTL使用了跟LinuxThread相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在NPTL库里调用)。但是，NPTL需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语futex.")]),_._v(" "),l("li",[_._v("NPTL也是一个1*1的线程库，就是说，当你使用pthread_create()调用创建一个线程后，在内核里就相应创建了一个调度实体，在linux里就是一个新进程，这个方法最大可能的简化了线程的实现。")]),_._v(" "),l("li",[_._v("除NPTL的1 * 1模型外还有一个m*n模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。")])])])])])}),[],!1,null,null,null);v.default=t.exports}}]);