<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>54. IO多路复用 | MSG</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="在追寻技术的同时享受生活">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.d65bef42.js" as="script"><link rel="preload" href="/assets/js/2.2249178e.js" as="script"><link rel="preload" href="/assets/js/120.bb5be863.js" as="script"><link rel="prefetch" href="/assets/js/10.4785e2e5.js"><link rel="prefetch" href="/assets/js/100.33fceff2.js"><link rel="prefetch" href="/assets/js/101.62e1e5d4.js"><link rel="prefetch" href="/assets/js/102.8551fe71.js"><link rel="prefetch" href="/assets/js/103.47754d79.js"><link rel="prefetch" href="/assets/js/104.4adf114f.js"><link rel="prefetch" href="/assets/js/105.6206a08a.js"><link rel="prefetch" href="/assets/js/106.1c4561f3.js"><link rel="prefetch" href="/assets/js/107.e1531a5a.js"><link rel="prefetch" href="/assets/js/108.c637743a.js"><link rel="prefetch" href="/assets/js/109.3f150913.js"><link rel="prefetch" href="/assets/js/11.bd8ec7a6.js"><link rel="prefetch" href="/assets/js/110.088c1ac3.js"><link rel="prefetch" href="/assets/js/111.66d8d491.js"><link rel="prefetch" href="/assets/js/112.231663ee.js"><link rel="prefetch" href="/assets/js/113.a38bc531.js"><link rel="prefetch" href="/assets/js/114.e165daea.js"><link rel="prefetch" href="/assets/js/115.994b087a.js"><link rel="prefetch" href="/assets/js/116.ea3cfdfb.js"><link rel="prefetch" href="/assets/js/117.7be5e4f3.js"><link rel="prefetch" href="/assets/js/118.ebb58ddb.js"><link rel="prefetch" href="/assets/js/119.90018646.js"><link rel="prefetch" href="/assets/js/12.0d8f43df.js"><link rel="prefetch" href="/assets/js/121.3d1db670.js"><link rel="prefetch" href="/assets/js/122.d29ed1b2.js"><link rel="prefetch" href="/assets/js/123.38cc4704.js"><link rel="prefetch" href="/assets/js/124.cc8549d4.js"><link rel="prefetch" href="/assets/js/125.6ee3e9c8.js"><link rel="prefetch" href="/assets/js/126.48710eba.js"><link rel="prefetch" href="/assets/js/127.d7a1fd83.js"><link rel="prefetch" href="/assets/js/128.e5017f6b.js"><link rel="prefetch" href="/assets/js/129.4c33e121.js"><link rel="prefetch" href="/assets/js/13.2dbde7aa.js"><link rel="prefetch" href="/assets/js/130.cda66247.js"><link rel="prefetch" href="/assets/js/131.ad76f669.js"><link rel="prefetch" href="/assets/js/132.aca88758.js"><link rel="prefetch" href="/assets/js/133.a1cf5903.js"><link rel="prefetch" href="/assets/js/134.b1386377.js"><link rel="prefetch" href="/assets/js/135.94edcf53.js"><link rel="prefetch" href="/assets/js/136.24be4170.js"><link rel="prefetch" href="/assets/js/137.db57772e.js"><link rel="prefetch" href="/assets/js/138.dc67bcaa.js"><link rel="prefetch" href="/assets/js/139.5453d1f6.js"><link rel="prefetch" href="/assets/js/14.2187dbf4.js"><link rel="prefetch" href="/assets/js/140.938e5c07.js"><link rel="prefetch" href="/assets/js/141.99c7cf2c.js"><link rel="prefetch" href="/assets/js/142.428e3958.js"><link rel="prefetch" href="/assets/js/143.68b01530.js"><link rel="prefetch" href="/assets/js/144.f67389cc.js"><link rel="prefetch" href="/assets/js/145.d952a130.js"><link rel="prefetch" href="/assets/js/146.b933dcad.js"><link rel="prefetch" href="/assets/js/147.2d8e4c0a.js"><link rel="prefetch" href="/assets/js/148.6d76ac94.js"><link rel="prefetch" href="/assets/js/149.6b4d6378.js"><link rel="prefetch" href="/assets/js/15.a53b356c.js"><link rel="prefetch" href="/assets/js/150.5bf39cb4.js"><link rel="prefetch" href="/assets/js/151.17af677c.js"><link rel="prefetch" href="/assets/js/152.7f1c2792.js"><link rel="prefetch" href="/assets/js/153.98dd0727.js"><link rel="prefetch" href="/assets/js/154.eb44bf23.js"><link rel="prefetch" href="/assets/js/155.5a9840ea.js"><link rel="prefetch" href="/assets/js/156.7ba01fd0.js"><link rel="prefetch" href="/assets/js/157.2296a048.js"><link rel="prefetch" href="/assets/js/158.6bb1f699.js"><link rel="prefetch" href="/assets/js/159.073bb8df.js"><link rel="prefetch" href="/assets/js/16.cef7bf44.js"><link rel="prefetch" href="/assets/js/160.25a837f9.js"><link rel="prefetch" href="/assets/js/161.93d886a1.js"><link rel="prefetch" href="/assets/js/162.5d2714b2.js"><link rel="prefetch" href="/assets/js/17.96f36904.js"><link rel="prefetch" href="/assets/js/18.fd04b310.js"><link rel="prefetch" href="/assets/js/19.3e1377d1.js"><link rel="prefetch" href="/assets/js/20.ac195ac8.js"><link rel="prefetch" href="/assets/js/21.c2d7729c.js"><link rel="prefetch" href="/assets/js/22.dd8c621b.js"><link rel="prefetch" href="/assets/js/23.ad7d0350.js"><link rel="prefetch" href="/assets/js/24.8559c4c3.js"><link rel="prefetch" href="/assets/js/25.783a8116.js"><link rel="prefetch" href="/assets/js/26.25e0e459.js"><link rel="prefetch" href="/assets/js/27.c0616e2a.js"><link rel="prefetch" href="/assets/js/28.30656c2e.js"><link rel="prefetch" href="/assets/js/29.2be5114c.js"><link rel="prefetch" href="/assets/js/3.be8c8f3b.js"><link rel="prefetch" href="/assets/js/30.230a74a7.js"><link rel="prefetch" href="/assets/js/31.760f46ad.js"><link rel="prefetch" href="/assets/js/32.c9533fef.js"><link rel="prefetch" href="/assets/js/33.dcacfb38.js"><link rel="prefetch" href="/assets/js/34.4370a466.js"><link rel="prefetch" href="/assets/js/35.bf299eea.js"><link rel="prefetch" href="/assets/js/36.336e435a.js"><link rel="prefetch" href="/assets/js/37.1d1d2eea.js"><link rel="prefetch" href="/assets/js/38.0d58b7d0.js"><link rel="prefetch" href="/assets/js/39.d43564ba.js"><link rel="prefetch" href="/assets/js/4.4a6cb970.js"><link rel="prefetch" href="/assets/js/40.bc4e4bde.js"><link rel="prefetch" href="/assets/js/41.b71231a5.js"><link rel="prefetch" href="/assets/js/42.9d46f400.js"><link rel="prefetch" href="/assets/js/43.50c5be69.js"><link rel="prefetch" href="/assets/js/44.60406e7f.js"><link rel="prefetch" href="/assets/js/45.ec3569ae.js"><link rel="prefetch" href="/assets/js/46.1bd3ce7b.js"><link rel="prefetch" href="/assets/js/47.1e1b5326.js"><link rel="prefetch" href="/assets/js/48.64c631ea.js"><link rel="prefetch" href="/assets/js/49.b4abacd8.js"><link rel="prefetch" href="/assets/js/5.e6d0b165.js"><link rel="prefetch" href="/assets/js/50.c3e320c0.js"><link rel="prefetch" href="/assets/js/51.5ec7fb8c.js"><link rel="prefetch" href="/assets/js/52.2d234f86.js"><link rel="prefetch" href="/assets/js/53.f3b69623.js"><link rel="prefetch" href="/assets/js/54.c85ff450.js"><link rel="prefetch" href="/assets/js/55.b07597b5.js"><link rel="prefetch" href="/assets/js/56.444129cf.js"><link rel="prefetch" href="/assets/js/57.df1329ba.js"><link rel="prefetch" href="/assets/js/58.5afb51cf.js"><link rel="prefetch" href="/assets/js/59.d98936d9.js"><link rel="prefetch" href="/assets/js/6.809376cd.js"><link rel="prefetch" href="/assets/js/60.02813ecf.js"><link rel="prefetch" href="/assets/js/61.37a4812d.js"><link rel="prefetch" href="/assets/js/62.5da94048.js"><link rel="prefetch" href="/assets/js/63.8e2c2bca.js"><link rel="prefetch" href="/assets/js/64.d290398f.js"><link rel="prefetch" href="/assets/js/65.44e28313.js"><link rel="prefetch" href="/assets/js/66.9acf0206.js"><link rel="prefetch" href="/assets/js/67.85688aa2.js"><link rel="prefetch" href="/assets/js/68.45bda7fc.js"><link rel="prefetch" href="/assets/js/69.9074feb0.js"><link rel="prefetch" href="/assets/js/7.5d7bce6e.js"><link rel="prefetch" href="/assets/js/70.b4cd2ddc.js"><link rel="prefetch" href="/assets/js/71.53219b13.js"><link rel="prefetch" href="/assets/js/72.af2a7290.js"><link rel="prefetch" href="/assets/js/73.c28fc506.js"><link rel="prefetch" href="/assets/js/74.64c81a90.js"><link rel="prefetch" href="/assets/js/75.05191ece.js"><link rel="prefetch" href="/assets/js/76.f516d464.js"><link rel="prefetch" href="/assets/js/77.c345180b.js"><link rel="prefetch" href="/assets/js/78.4a09d0ba.js"><link rel="prefetch" href="/assets/js/79.65f41bcf.js"><link rel="prefetch" href="/assets/js/8.f6cfdc07.js"><link rel="prefetch" href="/assets/js/80.b77151f3.js"><link rel="prefetch" href="/assets/js/81.824fa371.js"><link rel="prefetch" href="/assets/js/82.3f91c09b.js"><link rel="prefetch" href="/assets/js/83.9539f074.js"><link rel="prefetch" href="/assets/js/84.dd89f1de.js"><link rel="prefetch" href="/assets/js/85.15210b99.js"><link rel="prefetch" href="/assets/js/86.e14553e1.js"><link rel="prefetch" href="/assets/js/87.6dc95177.js"><link rel="prefetch" href="/assets/js/88.09c5e890.js"><link rel="prefetch" href="/assets/js/89.0d61f4d0.js"><link rel="prefetch" href="/assets/js/9.759f1986.js"><link rel="prefetch" href="/assets/js/90.a9b14d80.js"><link rel="prefetch" href="/assets/js/91.1a4aabe2.js"><link rel="prefetch" href="/assets/js/92.12070bdb.js"><link rel="prefetch" href="/assets/js/93.b5dc76d0.js"><link rel="prefetch" href="/assets/js/94.690498a6.js"><link rel="prefetch" href="/assets/js/95.b17961e6.js"><link rel="prefetch" href="/assets/js/96.a2f06f3e.js"><link rel="prefetch" href="/assets/js/97.64ef6721.js"><link rel="prefetch" href="/assets/js/98.443eba26.js"><link rel="prefetch" href="/assets/js/99.b6ba7c3a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">MSG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python文档" class="dropdown-title"><span class="title">Python文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="Python文档" class="mobile-dropdown-title"><span class="title">Python文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Python/1.Python-Basics/" class="nav-link">
  Python-基础
</a></li><li class="dropdown-item"><!----> <a href="/Python/2. Python-object/" class="nav-link">
  Python-面向对象
</a></li><li class="dropdown-item"><!----> <a href="/Python/3. Python-module/" class="nav-link">
  Python-模块与包
</a></li><li class="dropdown-item"><!----> <a href="/Python/4. Python-network/" class="nav-link">
  Python-网络
</a></li><li class="dropdown-item"><!----> <a href="/Python/5. Python-frontend/" class="nav-link">
  Python-前端
</a></li><li class="dropdown-item"><!----> <a href="/Python/6. Python-MySQL/" class="nav-link">
  Python-数据库
</a></li><li class="dropdown-item"><!----> <a href="/Python/7. Python-Django/" class="nav-link">
  Python-Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="容器文档" class="dropdown-title"><span class="title">容器文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="容器文档" class="mobile-dropdown-title"><span class="title">容器文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Container/docker/" class="nav-link">
  docker文檔
</a></li><li class="dropdown-item"><!----> <a href="/Container/Kubernetes/" class="nav-link">
  Kubernetes文檔
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GO文档" class="dropdown-title"><span class="title">GO文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="GO文档" class="mobile-dropdown-title"><span class="title">GO文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/GO/basics/" class="nav-link">
  GO快速入门
</a></li><li class="dropdown-item"><!----> <a href="/GO/module/" class="nav-link">
  GO标准库/GO模块
</a></li></ul></div></div><div class="nav-item"><a href="https://www.linux91.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python文档" class="dropdown-title"><span class="title">Python文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="Python文档" class="mobile-dropdown-title"><span class="title">Python文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Python/1.Python-Basics/" class="nav-link">
  Python-基础
</a></li><li class="dropdown-item"><!----> <a href="/Python/2. Python-object/" class="nav-link">
  Python-面向对象
</a></li><li class="dropdown-item"><!----> <a href="/Python/3. Python-module/" class="nav-link">
  Python-模块与包
</a></li><li class="dropdown-item"><!----> <a href="/Python/4. Python-network/" class="nav-link">
  Python-网络
</a></li><li class="dropdown-item"><!----> <a href="/Python/5. Python-frontend/" class="nav-link">
  Python-前端
</a></li><li class="dropdown-item"><!----> <a href="/Python/6. Python-MySQL/" class="nav-link">
  Python-数据库
</a></li><li class="dropdown-item"><!----> <a href="/Python/7. Python-Django/" class="nav-link">
  Python-Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="容器文档" class="dropdown-title"><span class="title">容器文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="容器文档" class="mobile-dropdown-title"><span class="title">容器文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Container/docker/" class="nav-link">
  docker文檔
</a></li><li class="dropdown-item"><!----> <a href="/Container/Kubernetes/" class="nav-link">
  Kubernetes文檔
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GO文档" class="dropdown-title"><span class="title">GO文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="GO文档" class="mobile-dropdown-title"><span class="title">GO文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/GO/basics/" class="nav-link">
  GO快速入门
</a></li><li class="dropdown-item"><!----> <a href="/GO/module/" class="nav-link">
  GO标准库/GO模块
</a></li></ul></div></div><div class="nav-item"><a href="https://www.linux91.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Python-网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Python/4.%20Python-network/" aria-current="page" class="sidebar-link">介绍</a></li><li><a href="/Python/4. Python-network/46. socket模块 - 网络套接字模块.html" class="sidebar-link">46. socket模块 - 网络套接字模块</a></li><li><a href="/Python/4. Python-network/47. subprocess模块.html" class="sidebar-link">47. subprocess模块</a></li><li><a href="/Python/4. Python-network/48. struct模块、hmac模块、处理TCP的粘包问题.html" class="sidebar-link">48. struct模块、hmac模块、处理TCP的粘包问题</a></li><li><a href="/Python/4. Python-network/49. 进程 - 理论知识.html" class="sidebar-link">49. 进程 - 理论知识</a></li><li><a href="/Python/4. Python-network/50. multiprocessing进程管理模块.html" class="sidebar-link">50. multiprocessing进程管理模块</a></li><li><a href="/Python/4. Python-network/51. 线程 - 理念知识.html" class="sidebar-link">51. 线程 - 理念知识</a></li><li><a href="/Python/4. Python-network/52. threading线程管理模块、queue队列模块、concurrent线程池模块.html" class="sidebar-link">52. threading线程管理模块、queue队列模块、concurrent线程池模块</a></li><li><a href="/Python/4. Python-network/53. 协程、Greenlet模块、Gevent模块.html" class="sidebar-link">53. 协程、Greenlet模块、Gevent模块</a></li><li><a href="/Python/4. Python-network/54. IO多路复用.html" class="active sidebar-link">54. IO多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#实验-使用非阻塞io模块来实现tcp聊天" class="sidebar-link">实验 - 使用非阻塞IO模块来实现TCP聊天</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#非阻塞io模型绝不被推荐的理由。" class="sidebar-link">非阻塞IO模型绝不被推荐的理由。</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#select模块-i-o多路复用" class="sidebar-link">select模块 - I/O多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#select模块的简单功能介绍" class="sidebar-link">select模块的简单功能介绍</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#实验-使用多路复用io模块来实现tcp聊天" class="sidebar-link">实验 - 使用多路复用IO模块来实现TCP聊天</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#select监听fd变化的过程分析" class="sidebar-link">select监听fd变化的过程分析</a></li></ul></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#io多路复用之三大模型-select、poll、epoll" class="sidebar-link">IO多路复用之三大模型-select、poll、epoll</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#select" class="sidebar-link">select</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#poll" class="sidebar-link">poll</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#epoll" class="sidebar-link">epoll</a></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#总结" class="sidebar-link">总结：</a></li></ul></li><li class="sidebar-sub-header"><a href="/Python/4. Python-network/54. IO多路复用.html#多路复用io模块的优缺点" class="sidebar-link">多路复用IO模块的优缺点</a></li></ul></li><li><a href="/Python/4. Python-network/55. 网络编程大作业 - 类网盘项目.html" class="sidebar-link">55. 网络编程大作业 - 类网盘项目</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_54-io多路复用"><a href="#_54-io多路复用" class="header-anchor">#</a> 54. IO多路复用</h1> <h1 id="io模型介绍-理论知识"><a href="#io模型介绍-理论知识" class="header-anchor">#</a> IO模型介绍 - 理论知识</h1> <p>为了更好地了解IO模型，我们需要事先回顾下：同步、异步、阻塞、非阻塞</p> <p>同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）</p> <p>IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，</p> <p>比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。</p> <p>所以，为了更好的回答这个问题，我先限定一下本文的上下文</p> <p>本文讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂</p> <p>Stevens在文章中一共比较了五种IO Model：</p> <ol><li>blocking IO           阻塞IO</li> <li>nonblocking IO      非阻塞IO</li> <li>IO multiplexing      IO多路复用</li> <li>signal driven IO     信号驱动IO</li> <li>asynchronous IO    异步IO</li></ol> <p>由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。</p> <p>IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段</p> <ol><li>等待数据准备 (Waiting for the data to be ready)</li> <li>将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</li></ol> <p>这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况</p> <h1 id="阻塞io-blocking-io-理论知识"><a href="#阻塞io-blocking-io-理论知识" class="header-anchor">#</a> 阻塞IO(blocking IO) - 理论知识</h1> <p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p> <p><img src="https://s2.ax1x.com/2019/11/07/MkzsMj.png" alt="MkzsMj.png"></p> <p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。</p> <p>而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p> <p><strong>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</strong></p> <p>几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，使用这些接口可以很方便的构建服务器/客户机的模型。然而大部分的socket接口都是阻塞型的。如下图</p> <p>ps：所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。</p> <p><img src="https://s2.ax1x.com/2019/11/07/MkzgZq.png" alt="MkzgZq.png"></p> <p>实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p> <p><strong>一个简单的解决方案：</strong></p> <p>在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接</p> <p><strong>该方案的问题是：</strong></p> <p>开启多进程或多线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。</p> <p><strong>改进方案：</strong></p> <p>很多程序员可能会考虑使用“线程池”或“连接池”。</p> <p>“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。</p> <p>“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。</p> <p>这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。</p> <p><strong>改进后方案其实也存在着问题：</strong></p> <p>“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。</p> <p>而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。</p> <p>所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p> <p><strong>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p> <h1 id="非阻塞io-non-blocking-io-不推荐使用"><a href="#非阻塞io-non-blocking-io-不推荐使用" class="header-anchor">#</a> 非阻塞IO(non-blocking IO) - 不推荐使用</h1> <p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p> <p><img src="https://s2.ax1x.com/2019/11/07/Mkzyss.png" alt="Mkzyss.png"></p> <p>从图中可以看出，</p> <ol><li>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。</li> <li>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</li> <li>用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。</li> <li>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。</li> <li>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。</li> <li>进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。</li> <li>重复上面的过程，循环往复的进行recvform系统调用。</li> <li>这个过程通常被称之为轮询。
<ol><li>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</li></ol></li></ol> <h2 id="实验-使用非阻塞io模块来实现tcp聊天"><a href="#实验-使用非阻塞io模块来实现tcp聊天" class="header-anchor">#</a> 实验 - 使用非阻塞IO模块来实现TCP聊天</h2> <p>在非阻塞式IO中，服务器进程其实是需要不断的主动询问kernel数据准备好了没有</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">## 服务器代码</span>
<span class="token keyword">import</span> socket
sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment">## 把阻塞等待的方法变成报错</span>
sk<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">## 服务器的IP跟端口</span>
sk<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 开启连接</span>

l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">## 已连接客户端的列表</span>
del_l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">## 已处理客户端的列表，需要按这个列表来清除 l 列表的数据</span>
<span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">,</span>addr <span class="token operator">=</span> sk<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 目前是，如果没有连接请求，会报错，就要进行异常处理，如果是阻塞IO模型，在这里程序会一直等待。</span>
        l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token comment"># 将每个请求连接的客户端的conn添加到列表中</span>
        <span class="token comment">## 这区域进行无限的循环接收连接请求，直到没有连接请求，才执行下面代码，去处理已接收到的连接请求</span>
    <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>   <span class="token comment">## 如果接收不到数据程序报错，由这行进行处理，执行以下代码</span>
        <span class="token keyword">for</span> conn <span class="token keyword">in</span> l<span class="token punctuation">:</span><span class="token comment"># 去遍历所有客户端发送的的连接conn，看看有没有客户端给我发送数据了</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                info <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token comment"># 尝试接收，看看有没有客户端给我发数据</span>
                <span class="token keyword">if</span> <span class="token keyword">not</span> info<span class="token punctuation">:</span><span class="token comment"># 如果客户端正常执行了close，服务器会接收到一个空，就是客户端正常结果，默认会发送一个空值给服务端</span>
                    del_l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token comment"># 将已经结束的客户端的conn，添加到要删除的列表中</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'客户端正常退出了!'</span><span class="token punctuation">)</span>
                    conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 因为客户端已经主动close，所以服务器端的conn也要close，客户端断开了连接，服务端也要断开连接</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment">## 如果接收不为空，那就证明客户端向服务端发送数据了</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span>
                    conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>info<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">## 回复客户端信息</span>
            <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>
                <span class="token keyword">continue</span><span class="token comment"># 是没有接受到客户端发来的数据而报错</span>
            <span class="token keyword">except</span> ConnectionResetError<span class="token punctuation">:</span>
                <span class="token keyword">pass</span><span class="token comment"># 是因为客户端强制退出而报错</span>
        <span class="token keyword">if</span> del_l<span class="token punctuation">:</span>
            <span class="token keyword">for</span> conn <span class="token keyword">in</span> del_l<span class="token punctuation">:</span>
                l<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
            del_l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 在删除完主动关闭的客户端的连接之后，应该把此列表清空，否则报错</span>
            
            
<span class="token comment">## 客户端代码</span>
<span class="token keyword">import</span> socket
sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
    msg_s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'&gt;&gt;&gt;'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> msg_s<span class="token punctuation">:</span><span class="token keyword">continue</span>
    <span class="token keyword">if</span> msg_s <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span><span class="token keyword">break</span>
    sk<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg_s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sk<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">## 可以开几个客户端来测试,会发现客户端跟服务端通信,就像是并发一样,同时跟多客户端通信</span>
<span class="token comment">## 但实际是伪并发</span>
</code></pre></div><h2 id="非阻塞io模型绝不被推荐的理由。"><a href="#非阻塞io模型绝不被推荐的理由。" class="header-anchor">#</a> 非阻塞IO模型绝不被推荐的理由。</h2> <p>我们不能否则其优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）</p> <p>但是也难掩其缺点：</p> <ol><li>循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况</li> <li>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低</li></ol> <h1 id="多路复用io-io-multiplexing-推荐使用"><a href="#多路复用io-io-multiplexing-推荐使用" class="header-anchor">#</a> 多路复用IO(IO multiplexing) - 推荐使用</h1> <p>IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p> <p>它的流程如图:</p> <p><img src="https://s2.ax1x.com/2019/11/07/Mkz6Ln.png" alt="Mkz6Ln.png"></p> <p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p> <p>这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p> <p><strong>总结:</strong></p> <ol><li><p>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p></li> <li><p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p></li> <li><p>结论: select的优势在于可以处理多个连接，不适用于单个连接</p></li></ol> <h2 id="select模块-i-o多路复用"><a href="#select模块-i-o多路复用" class="header-anchor">#</a> select模块 - I/O多路复用</h2> <p>Python中的select模块专注于I/O多路复用</p> <p>提供了select poll epoll三个方法(其中后两个在Linux中可用，windows仅支持select)</p> <p>另外也提供了kqueue方法(freeBSD系统),select 方法允许你响应不同 socket 的多个事件以及其它不同事件。</p> <p>例如你可以让 select 在某个 socket 有数据到达时，或者当某个 socket 可以写数据时，又或者是当某个 socket 发生错误时通知你，好处是你可以同时响应很多 socket 的多个事件</p> <p><strong>select 、poll 、epoll的区别</strong></p> <ol><li>select和poll有一个共同的机制，都是采用轮训的方式去询问内核，有没有数据准备好了
<ol><li>select有一个最大监听事件的限制，32位机限制1024，,6位机限制2048</li> <li>因为是使用了轮询的方式去询问 , 这样也对系统内存跟CPU有一定的压力</li></ol></li> <li>poll没有，理论上poll可以开启无限大，1G内存大概够你开10W个事件去监听
<ol><li>因为是使用了轮询的方式去询问 , 这样也对系统内存跟CPU有一定的压力</li></ol></li> <li>epoll是最好的，采用的是回调机制，解决了select和poll共同存在的问题
<ol><li>而且epoll理论上也可以开启无限多个监听事件</li></ol></li></ol> <h3 id="select模块的简单功能介绍"><a href="#select模块的简单功能介绍" class="header-anchor">#</a> select模块的简单功能介绍</h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> select
r<span class="token punctuation">,</span>w<span class="token punctuation">,</span>x <span class="token operator">=</span> select<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

select中有三个参数<span class="token punctuation">:</span>
三个参数都是 <span class="token builtin">list</span> 类型，
    r：读事件
    w：写事件
    x：错误事件

同样方法返回值也是三个 <span class="token builtin">list</span>，包含的是哪些事件（读、写、异常）
    
<span class="token comment">## 源码的解释</span>
rlist <span class="token operator">-</span><span class="token operator">-</span> wait until ready <span class="token keyword">for</span> reading
wlist <span class="token operator">-</span><span class="token operator">-</span> wait until ready <span class="token keyword">for</span> writing
xlist <span class="token operator">-</span><span class="token operator">-</span> wait <span class="token keyword">for</span> an ``exceptional condition
</code></pre></div><h3 id="实验-使用多路复用io模块来实现tcp聊天"><a href="#实验-使用多路复用io模块来实现tcp聊天" class="header-anchor">#</a> <strong>实验 - 使用多路复用IO模块来实现TCP聊天</strong></h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">## 服务端代码</span>
<span class="token keyword">import</span> select
<span class="token keyword">import</span> socket

sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span>
del_l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
rlist <span class="token operator">=</span> <span class="token punctuation">[</span>sk<span class="token punctuation">]</span><span class="token comment"># 是用来让select帮忙监听的 所有 接口</span>
<span class="token comment"># select：windows/linux是监听事件有没有数据到来</span>
<span class="token comment"># poll:  linux   也可以做select的工作</span>
<span class="token comment"># epoll: linux   也可以做类似的工作</span>
<span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
    r<span class="token punctuation">,</span>w<span class="token punctuation">,</span>x <span class="token operator">=</span> select<span class="token punctuation">.</span>select<span class="token punctuation">(</span>rlist<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 传参给select，当rlist列表中哪个接口有反应，就返回给r这个列表</span>
    <span class="token keyword">if</span> r<span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> r<span class="token punctuation">:</span><span class="token comment"># 循环遍历r，看看有反应的接口到底是sk  还是conn</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> sk<span class="token punctuation">:</span>
                <span class="token comment"># 如果是sk，那就表示有客户端的连接请求</span>
                <span class="token triple-quoted-string string">'''sk有数据要接收，代表着有客户端要来连接'''</span>
                conn<span class="token punctuation">,</span>addr <span class="token operator">=</span> i<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
                rlist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token comment"># 把新的客户端的连接，添加到rlist，继续让select帮忙监听</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 如果是conn，就表示有客户端给我发数据了</span>
                <span class="token triple-quoted-string string">'''conn有数据要接收，代表要使用recv'''</span>
                <span class="token keyword">try</span><span class="token punctuation">:</span>
                    msg_r <span class="token operator">=</span> i<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> msg_r<span class="token punctuation">:</span>
                        <span class="token triple-quoted-string string">'''客户端执行了close，客户端主动正常关闭连接'''</span>
                        del_l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                        i<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span>msg_r<span class="token punctuation">)</span>
                        i<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg_r<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">except</span> ConnectionResetError<span class="token punctuation">:</span>
                    <span class="token keyword">pass</span>
        <span class="token keyword">if</span> del_l<span class="token punctuation">:</span><span class="token comment"># 删除那些主动断开连接的客户端的conn</span>
            <span class="token keyword">for</span> conn <span class="token keyword">in</span> del_l<span class="token punctuation">:</span>
                rlist<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
            del_l<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
            
            
<span class="token comment">## 客户端代码：</span>
<span class="token keyword">import</span> socket
sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
    msg_s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'&gt;&gt;&gt;'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> msg_s<span class="token punctuation">:</span><span class="token keyword">continue</span>
    <span class="token keyword">if</span> msg_s <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span><span class="token keyword">break</span>
    sk<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg_s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sk<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sk<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">## 这样就大大利用了程序遇到IO阻塞时的利用</span>
</code></pre></div><h3 id="select监听fd变化的过程分析"><a href="#select监听fd变化的过程分析" class="header-anchor">#</a> select监听fd变化的过程分析</h3> <p>用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到。</p> <p>用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。</p> <h2 id="io多路复用之三大模型-select、poll、epoll"><a href="#io多路复用之三大模型-select、poll、epoll" class="header-anchor">#</a> IO多路复用之三大模型-select、poll、epoll</h2> <p><strong>IO复用：</strong></p> <ol><li>为了解释这个名词，首先来理解下复用这个概念，复用也就是共用的意思，这样理解还是有些抽象，</li> <li>为此，咱们来理解下复用在通信领域的使用，
<ol><li>在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或频分复用的技术使其在同一链路上传输多路信号，</li> <li>到这里我们就基本上理解了复用的含义，即公用某个“介质”来尽可能多的做同一类(性质)的事，那IO复用的“介质”是什么呢？</li></ol></li> <li>为此我们首先来看看服务器编程的模型，
<ol><li>客户端发来的请求服务端会产生一个进程来对其进行服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了IO复用技术，</li> <li>即：一个进程可以同时对多个客户请求进行服务。</li></ol></li> <li>也就是说IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。</li></ol> <p><strong>理解完IO复用后，我们在来看下实现IO复用中的三个API(select、poll和epoll)的区别和联系</strong></p> <p>select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：</p> <ol><li>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</li> <li>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</li> <li>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</li></ol> <h3 id="select"><a href="#select" class="header-anchor">#</a> <strong>select</strong></h3> <p>select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。第二三四参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件，所以每次调用select前都需要重新初始化fdset。timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。</p> <p><strong>select的调用步骤如下：</strong></p> <ol><li>使用copy_from_user从用户空间拷贝fdset到内核空间</li> <li>注册回调函数__pollwait</li> <li>遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</li> <li>以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。__</li> <li>pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll 来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数 据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</li> <li>poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</li> <li>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</li> <li>把fd_set从内核空间拷贝到用户空间。</li></ol> <p><strong>总结下select的几大缺点：</strong></p> <ol><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li> <li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li> <li>select支持的文件描述符数量太小了，默认是1024</li></ol> <h3 id="poll"><a href="#poll" class="header-anchor">#</a> <strong>poll</strong></h3> <p>poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</p> <p>poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。</p> <h3 id="epoll"><a href="#epoll" class="header-anchor">#</a> <strong>epoll</strong></h3> <p><strong>直到Linux2.6 才出现了由内核直接支持的实现方法，那就是epoll，</strong></p> <ol><li>被公认为Linux2.6下性能最好的多路I/O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），</li> <li>理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，</li> <li>这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。</li> <li>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li></ol> <p><strong>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。</strong></p> <ol><li>那epoll都是怎么解决的呢？在此之前，我们先看一下epoll 和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。</li> <li>而epoll提供了三个函 数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注 册要监听的事件类型；epoll_wait则是等待事件的产生。</li></ol> <p><strong>三个缺点</strong></p> <ol><li>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定 EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。
<ol><li>epoll保证了每个fd在整个过程中只会拷贝 一次。</li></ol></li> <li>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在 epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调 函数，而这个回调函数会把就绪的fd加入一个就绪链表）。
<ol><li>epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用 schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</li></ol></li> <li>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子, 在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</li></ol> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> <strong>总结：</strong></h3> <ol><li><p>select，poll 实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。</p> <ol><li>虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</li></ol></li> <li><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销。</p></li></ol> <h2 id="多路复用io模块的优缺点"><a href="#多路复用io模块的优缺点" class="header-anchor">#</a> 多路复用IO模块的优缺点</h2> <p><strong>优点：</strong></p> <ol><li>相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。</li> <li>如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。</li></ol> <p><strong>缺点：</strong></p> <ol><li>首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。</li> <li>很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。</li> <li>如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，</li> <li>所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。</li> <li>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</li></ol> <h1 id="异步io-asynchronous-i-o-理论知识"><a href="#异步io-asynchronous-i-o-理论知识" class="header-anchor">#</a> 异步IO(Asynchronous I/O) - 理论知识</h1> <p>Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程：</p> <p><img src="https://s2.ax1x.com/2019/11/07/Mkz2d0.png" alt="Mkz2d0.png"></p> <p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而</p> <p>另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。</p> <p>然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了</p> <p>python不支持异步IO模块的实现</p> <h1 id="io模型比较分析-理论知识"><a href="#io模型比较分析-理论知识" class="header-anchor">#</a> IO模型比较分析 - 理论知识</h1> <p>到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：阻塞IOblocking和非阻塞IOnon-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。</p> <p>先回答最简单的这个：阻塞IOblocking 跟 非阻塞IOnon-blocking。</p> <ol><li>前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</li></ol> <p>再说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：</p> <ol><li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;</li> <li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li> <li>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，四个IO模型可以分为两大类，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO这一类，而 asynchronous I/O后一类 。</li></ol> <p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p> <p>各个IO Model的比较如图所示：</p> <p><img src="https://s2.ax1x.com/2019/11/07/MkzRoV.png" alt="MkzRoV.png"></p> <p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Python/4. Python-network/53. 协程、Greenlet模块、Gevent模块.html" class="prev">
        53. 协程、Greenlet模块、Gevent模块
      </a></span> <span class="next"><a href="/Python/4. Python-network/55. 网络编程大作业 - 类网盘项目.html">
        55. 网络编程大作业 - 类网盘项目
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d65bef42.js" defer></script><script src="/assets/js/2.2249178e.js" defer></script><script src="/assets/js/120.bb5be863.js" defer></script>
  </body>
</html>
